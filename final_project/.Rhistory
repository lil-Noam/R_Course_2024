top3 = top_n(linear_model, df, 3)
top5 = top_n(linear_model, df, 5)
top10 = top_n(linear_model, df, 10)
save_roc(top3)
top3
top5
top10
top10
feature_importance(linear_model10)
feature_selection(linear_model, 10)
feature_selection(result, df, 10)
feature_selection(result, 10)
feature_selection(result$coef, 10)
source("~/.active-rstudio-document", echo=TRUE)
source("~/GitHub/R_Course_2024/final_project/top_features_modeling.R", echo=TRUE)
linear_model
logistic_model
rfe_model
View(rfe_model)
# Train a random forest model
rf_model <- randomForest(event_memory ~ ., data = df[5:length(df)], importance = TRUE)
library(randomForest)
# Train a random forest model
rf_model <- randomForest(event_memory ~ ., data = df[5:length(df)], importance = TRUE)
# View feature importance
importance(rf_model)
# Plot the importance
varImpPlot(rf_model)
# random forest model
rf_model = randomForest(event_memory ~ . - event_effect, data = df[5:length(df)], importance = TRUE)
# View importance
importance(rf_model)
# Plot importance
varImpPlot(rf_model)
# random forest model
rf_model = randomForest(event_memory ~ . - event_effect - MEGA_memory, data = df[5:length(df)], importance = TRUE)
# View importance
importance(rf_model)
# Plot importance
varImpPlot(rf_model)
library(caret)
library(randomForest)
# Recursive Feature Elimination
rfe_model = rfe(df[, 8:length(df)], df$MEGA_memory,
sizes = c(1:10),
rfeControl = rfeControl(functions = rfFuncs, method = "cv"))
print(rfe_model)
# random forest model
rf_model = randomForest(MEGA_memory ~ . - event_effect - event_memory, data = df[5:length(df)], importance = TRUE)
# View importance
importance(rf_model)
# Plot importance
varImpPlot(rf_model)
top_10_features = rfe_model$optVariables
top_10_features
result
source("~/GitHub/R_Course_2024/final_project/preprocess_EDA.R", echo=TRUE)
source("~/GitHub/R_Course_2024/final_project/analysis.R", echo=TRUE)
source("~/GitHub/R_Course_2024/final_project/RF_RFE.R", echo=TRUE)
result$coef
result$coef$Movie
rfe_importance
importance$rf_model
importance(rf_model)
importance(rf_model)
varImpPlot(rf_model)
varImpPlot(rf_model)
importance_values = importance(rf_model)
importance_values
# Sort importance values in descending order
sorted_importance = importance_values[order(-importance_values[, 1]),]
# Print sorted importance
print(sorted_importance)
rfe_importance
source("~/GitHub/R_Course_2024/final_project/RF_RFE.R", echo=TRUE)
rf_importance_values = importance(rf_model)
rf_sorted_importance = importance_values[order(-importance_values[, 1]),]
rf_movies = rownames(sorted_importance)
importance_df = data.frame(LR = result$coef$Movie, RFE = rfe_importance, RF = rf_movies)
print(importance_df)
library(tidyr)
library(ggplot2)
# Reshape data to long format
importance_df_long <- importance_df %>%
gather(key = "Model", value = "Movie", LR, RFE, RF)  # Long format for ggplot
# View the reshaped data
head(importance_df_long)
# Create a plot where movie names are placed according to their rank in each model
ggplot(importance_df_long, aes(x = Model, y = rank(Movie), color = Movie)) +
geom_point(size = 3) +
geom_line(aes(group = Movie), color = "gray", alpha = 0.5) +  # Optional: line to connect rankings
labs(title = "Movie Rankings Across Models (LR, RFE, RF)",
x = "Model",
y = "Rank",
color = "Movie") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_color_discrete(guide = guide_legend(title = "Movie"))
library(dplyr)
library(tidyr)
# Create a ranking column for each model (LR, RFE, RF)
importance_df_with_ranks <- importance_df %>%
mutate(
LR_rank = rank(LR),
RFE_rank = rank(RFE),
RF_rank = rank(RF)
)
# View the data with rankings
head(importance_df_with_ranks)
# Check the order of the movies in each model
model_order_LR <- importance_df$LR
model_order_RFE <- importance_df$RFE
model_order_RF  <- importance_df$RF
# View the first few rows of each
head(model_order_LR)
head(model_order_RFE)
head(model_order_RF)
library(dplyr)
# Add a common ranking system to ensure consistency in ranking across models
importance_df_with_ranks <- importance_df %>%
mutate(
LR_rank = rank(-as.numeric(factor(LR))),  # You can use any metric that makes sense here
RFE_rank = rank(-as.numeric(factor(RFE))),
RF_rank = rank(-as.numeric(factor(RF)))
)
# Check the adjusted ranking data
head(importance_df_with_ranks)
importance_df = data.frame(LR = result$coef$Movie, RFE = rfe_importance, RF = rf_movies)
print(importance_df)
# Create a new dataframe based on the LR column order and rank
importance_df_ranked <- importance_df %>%
arrange(LR) %>%
mutate(
LR_rank = row_number(),  # Rank based on the order in LR
RFE_rank = match(RFE, importance_df$RFE),  # Match RFE to its rank based on the sorted order
RF_rank = match(RF, importance_df$RF)     # Match RF to its rank based on the sorted order
)
# Check the new ranked data frame
head(importance_df_ranked)
# Initialize empty vectors to store the indices
LR_indices <- numeric(nrow(importance_df))
RFE_indices <- numeric(nrow(importance_df))
RF_indices <- numeric(nrow(importance_df))
movie_id = importance_df$LR
# Loop over each row and check where the movie is in each column
for(i in 1:nrow(importance_df)) {
LR_indices[i] <- which(importance_df$LR == movie_id[i])
RFE_indices[i] <- which(importance_df$RFE == movie_id[i])
RF_indices[i] <- which(importance_df$RF == movie_id[i])
}
indices_df <- data.frame(
Movie_ID = movie_id,
LR_index = LR_indices,
RFE_index = RFE_indices,
RF_index = RF_indices
)
# View the new dataframe with indices
print(indices_df)
importance_df = data.frame(LR = result$coef$Movie, RFE = rfe_importance, RF = rf_movies)
print(importance_df)
# Initialize empty vectors to store the indices
LR_indices <- numeric(nrow(importance_df))
RFE_indices <- numeric(nrow(importance_df))
RF_indices <- numeric(nrow(importance_df))
movie_id = importance_df$LR
# Loop over each row and check where the movie is in each column
for(i in 1:nrow(importance_df)) {
LR_indices[i] <- which(importance_df$LR == movie_id[i])
RFE_indices[i] <- which(importance_df$RFE == movie_id[i])
RF_indices[i] <- which(importance_df$RF == movie_id[i])
}
indices_df <- data.frame(
Movie_ID = movie_id,
LR_index = LR_indices,
RFE_index = RFE_indices,
RF_index = RF_indices
)
# View the new dataframe with indices
print(indices_df)
# Load necessary library
library(ggplot2)
library(tidyr)
# Create a long-format dataframe
indices_df_long <- indices_df %>%
pivot_longer(cols = c(LR_index, RFE_index, RF_index),
names_to = "Model",
values_to = "Rank")
# Create the scatter plot
ggplot(indices_df_long, aes(x = Model, y = Rank, color = Movie_ID)) +
geom_point(size = 3) +  # Points for each movie
geom_line(aes(group = Movie_ID), color = "gray", alpha = 0.5) +  # Lines connecting the points for each movie
labs(title = "Movie Ranking Across Models (LR, RFE, RF)",
x = "Model",
y = "Rank") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for clarity
# Load necessary library
library(ggplot2)
library(tidyr)
library(dplyr)
# Sort the dataframe by LR_index
indices_df_sorted <- indices_df %>%
arrange(LR_index)  # Sorting by LR_index column
# Create a long-format dataframe
indices_df_long <- indices_df_sorted %>%
pivot_longer(cols = c(LR_index, RFE_index, RF_index),
names_to = "Model",
values_to = "Rank")
# Create the scatter plot
ggplot(indices_df_long, aes(x = Model, y = Rank, color = Movie_ID, group = Movie_ID)) +
geom_point(size = 3) +  # Points for each movie
geom_line(color = "gray", alpha = 0.5) +  # Lines connecting the points for each movie
labs(title = "Movie Ranking Across Models (LR, RFE, RF)",
x = "Model",
y = "Rank") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for clarity
indices_df
View(indices_df_long)
View(indices_df_long)
View(indices_df_sorted)
# Load necessary libraries
library(ggplot2)
library(tidyr)
library(dplyr)
# Sort the dataframe by LR_index
indices_df_sorted <- indices_df %>%
arrange(LR_index)  # Sorting by LR_index column
# Create a long-format dataframe
indices_df_long <- indices_df_sorted %>%
pivot_longer(cols = c(LR_index, RFE_index, RF_index),
names_to = "Model",
values_to = "Rank")
# Create the scatter plot
ggplot(indices_df_long, aes(x = Model, y = Rank, color = Movie_ID, group = Movie_ID)) +
geom_point(size = 3) +  # Points for each movie
geom_line(color = "gray", alpha = 0.5) +  # Lines connecting the points for each movie
labs(title = "Movie Ranking Across Models (LR, RFE, RF)",
x = "Model",
y = "Rank") +
scale_y_reverse() +  # Flip the y-axis so that top-ranked movies are at the top
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for clarity
library(dplyr)
library(readr)
library(tidyr)
setwd('C:\\Users\\user\\Documents\\Noam_Rcourse\\final_project')
### PREPROCESSING ----
# load the csv file into R
data = read_csv("data_MEGAproject.csv")
# add dummy for event memory
data = data |>
mutate(event_memory = ifelse(memorysource == 'event_memory', 1, 0),
Movie = gsub("mov([0-9])$", "mov0\\1", Movie),
MEGA_Z = scale(MEGA_score))
# count subjects and movies
subject_dict = unique(data$Subject)
movie_dict = sort(unique(data$Movie))
print(paste("the data contains", length((subject_dict)), "subjects and", length(movie_dict), "movies"))
# make new df of the relevant features only
df = data |> dplyr::select(Subject, Movie, MEGA_score, MEGA_Z, event_memory)
# factorizing event memory
df = df |>
mutate(event_memory = factor(df$event_memory, levels = c(0, 1), labels = c("No", "Yes")))
# Count the occurrences of 'Yes' and 'No' responses for each movie
movie_memory = df |>
group_by(Movie, event_memory) |>
summarise(count = n(), .groups = "drop") |>
pivot_wider(names_from = event_memory, values_from = count, values_fill = list(count = 0))
# Remove movies with 0 yes or 0 no
movie_memory_filtered = movie_memory |>
filter(Yes > 0 & No > 0)
# Join the filtered movie_memory with df to retain only movies with both Yes and No responses
df = df |>
filter(Movie %in% movie_memory_filtered$Movie)
# factorize movies, add event effect coding
df = df |>
mutate(Movie = factor(Movie),
event_effect = ifelse(event_memory ==  "Yes", 1, -1))
# create MEGA memory metric
df = df |>
mutate(MEGA_memory = MEGA_Z * event_effect)
# make dummy variable for each movie
dummy_dict = model.matrix(~ Movie - 1, data = df)
df = cbind(df, dummy_dict)
library(pROC)
library(lme4)
library(dplyr)
# set path
setwd('C:\\Users\\user\\Documents\\GitHub\\R_Course_2024\\final_project')
### helper functions for regressions ----
# for logistic regression:
logistic_analysis = function(model, data, outcome_var = "event_memory", predictor_var = "MEGA_Z", file_prefix = "Logistic_Analysis") {
# Generate predicted probabilities (fixed effects only and full prediction)
pred_prob_fixed = predict(model, type = "response", re.form = NA)  # Fixed effects only
pred_prob_full = predict(model, type = "response")  # Fixed + Random effects
# Compute and plot the ROC curve
roc_curve = roc(data[[outcome_var]], pred_prob_full)
roc_plot = plot(roc_curve, main = "ROC Curve for Logistic Regression Model", col = "blue", lwd = 2)
# Calculate AUC value and add to the plot
auc_value = auc(roc_curve)
text(0.6, 0.2, paste("AUC =", round(auc_value, 3)), col = "red", cex = 1.5)
# Print AUC value to console
print(paste("AUC:", auc_value))
# Store predicted probabilities in the data frame
data$pred_prob_fixed = pred_prob_fixed
data$pred_prob_full = pred_prob_full
# Plot the logistic regression: Predicted probabilities vs predictor (e.g., MEGA_score)
log_plot = ggplot(data, aes_string(x = predictor_var)) +
# Show the individual data points (raw data), colored by the actual event memory outcome (0 or 1)
geom_point(aes(y = pred_prob_full, color = as.factor(.data[[outcome_var]])), alpha = 0.7, size=2) +
# Plot the fixed effect line (general trend of predictor on predicted probability)
geom_line(aes(y = pred_prob_fixed), color = "blue", size = 1) +
labs(title = paste("Logistic Regression: Predicted Probability vs", predictor_var),
x = predictor_var, y = "Predicted Probability of Memory",
color = "Event Memory") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_color_manual(values = c("No" = "red", "Yes" = "green"))
# Return the plots
return(list(ROC_Plot = roc_plot, Logistic_Plot = log_plot))
}
save_roc = function(result) {
name = deparse(substitute(result))
roc_plot = result$ROC_Plot
jpeg(paste0("ROC_curve_",name,".jpeg"), width = 10, height = 10, units = "in", res = 300)
plot(roc_plot, main = paste0("ROC Curve for ", name, " Logistic Regression Model: ", name), col = "blue", lwd = 2)
text(0.6, 0.2, paste("AUC =", round(auc(result$ROC_Plot), 3)), col = "red", cex = 1.5)
dev.off()
}
# for linear regression:
feature_importance = function(model) {
movie_coef = coef(model)
movie_names = names(movie_coef)
# Sort the coefficients by absolute value in decreasing order
sorted_indices = order(abs(movie_coef), decreasing = TRUE)
# Apply the sorting to both the coefficients and the movie names
movie_coef_sorted = movie_coef[sorted_indices]
movies_sorted_by_coef = movie_names[sorted_indices]
# Create a data frame with the sorted movie names and coefficients
coef_df = data.frame(Movie = movies_sorted_by_coef, Coefficient = movie_coef_sorted)
coef_df$abs_coef = abs(coef_df$Coefficient)
coef_df$Sign = ifelse(coef_df$Coefficient > 0, "Positive", "Negative")
coef_df$Movie = factor(coef_df$Movie, levels = coef_df$Movie)
# Create a plot
plt = ggplot(coef_df, aes(x = Movie, y = abs_coef, color = Sign)) +
geom_point(size = 3) +
geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
theme_minimal() +
labs(title = "Movie Coefficients Sorted by Absolute Value", x = "Movie", y = "Coefficient") +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_color_manual(values = c("Positive" = "blue", "Negative" = "red"))
return(list(coef = coef_df, plot = plt))
}
feature_selection = function(coef_df, num_features=10) {
# in our case we want the movies that increase match between MEGA and memory
# therefore we only want the movies with positive coefficient
features = coef_df |>
filter(Sign=='Positive')
return(head(features, num_features))
}
### logistic regression ----
# Logistic regression model for memory by MEGA score
logistic_model = glmer(event_memory ~ MEGA_Z + (1|Subject), family = binomial, data = df)
log_result = logistic_analysis(logistic_model, df)
print(log_result$ROC_Plot)
print(log_result$Logistic_Plot)
# Save the ROC plot to a file
save_roc(log_result)
# Save the logit curve to a file
ggsave("LogPlot.jpeg", plot = log_result$Logistic_Plot, width = 14, height = 10, dpi = 300)
### linear regression ----
# linear regression for (MEGA_memory = MEGA Z score x event memory effect coding) by movie
# I first tried mixed model with random intercept for each subject
# but the sd was so small that I decided to switch back
linear_model = lm(MEGA_memory ~ Movie -1, data = df)
result = feature_importance(linear_model)
print(result$plot)
ggsave("feature_importance.jpeg", plot = result$plot, width = 12, height = 10, dpi = 300)
library(caret)
library(randomForest)
# Recursive Feature Elimination
rfe_model = rfe(df[, 8:length(df)], df$MEGA_memory,
sizes = c(1:10),
rfeControl = rfeControl(functions = rfFuncs, method = "cv"))
print(rfe_model)
rfe_importance = rfe_model$optVariables
print(rfe_importance)
# random forest model
rf_model = randomForest(MEGA_memory ~ . - event_effect - event_memory, data = df[5:length(df)], importance = TRUE)
# View importance
importance(rf_model)
# Plot importance
varImpPlot(rf_model)
rf_importance_values = importance(rf_model)
rf_sorted_importance = importance_values[order(-importance_values[, 1]),]
# Create plot
method_plot = ggplot(indices_df_long, aes(x = Model, y = Rank, color = Movie_ID, group = Movie_ID)) +
geom_point(size = 3) +  # Points for each movie
geom_line(color = "gray", alpha = 0.5) +  # Lines connecting the points for each movie
labs(title = "Movie Ranking Across Models (LR, RFE, RF)",
x = "Model",
y = "Rank") +
scale_y_reverse() +  # Flip the y-axis so that top-ranked movies are at the top
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for clarity
rf_importance_values = importance(rf_model)
rf_sorted_importance = rf_importance_values[order(-importance_values[, 1]),]
importance_df = data.frame(LR = result$coef$Movie, RFE = rfe_importance, RF = rf_movies)
rf_importance_values = importance(rf_model)
rf_sorted_importance = rf_importance_values[order(-importance_values[, 1]),]
rf_importance_values = importance(rf_model)
rf_sorted_importance = rf_importance_values[order(-rf_sorted_importance[, 1]),]
rf_importance_values = importance(rf_model)
rf_sorted_importance = rf_importance_values[order(-rf_importance_values[, 1]),]
rf_movies = rownames(rf_sorted_importance)
importance_df = data.frame(LR = result$coef$Movie, RFE = rfe_importance, RF = rf_movies)
rfe_importance
rfe_importance = rfe_model$optVariables
rfe_importance
rfe_model
View(rf_model)
library(doParallel)
install.packages("doParallel")
library(doParallel)
# Register parallel backend (e.g., 4 cores)
cl <- makeCluster(4)
registerDoParallel(cl)
# Run RFE with parallel processing
rfe_model = rfe(df[, 8:ncol(df)], df$MEGA_memory,
sizes = c(1:ncol(df) - 7),
rfeControl = rfeControl(functions = rfFuncs, method = "cv",
allowParallel = TRUE))
stopCluster(cl)
View(data)
# Recursive Feature Elimination
rfe_model = rfe(df[, 8:length(df)], df$MEGA_memory,
sizes = c(1:10),
rfeControl = rfeControl(functions = rfFuncs, method = "cv"))
# Recursive Feature Elimination
rfe_model = rfe(df[, 8:length(df)], df$MEGA_memory,
sizes = c(1:10),
rfeControl = rfeControl(functions = rfFuncs, method = "cv"))
library(dplyr)
library(readr)
library(tidyr)
setwd('C:\\Users\\user\\Documents\\Noam_Rcourse\\final_project')
### PREPROCESSING ----
# load the csv file into R
data = read_csv("data_MEGAproject.csv")
# add dummy for event memory
data = data |>
mutate(event_memory = ifelse(memorysource == 'event_memory', 1, 0),
Movie = gsub("mov([0-9])$", "mov0\\1", Movie),
MEGA_Z = scale(MEGA_score))
# count subjects and movies
subject_dict = unique(data$Subject)
movie_dict = sort(unique(data$Movie))
print(paste("the data contains", length((subject_dict)), "subjects and", length(movie_dict), "movies"))
# make new df of the relevant features only
df = data |> dplyr::select(Subject, Movie, MEGA_score, MEGA_Z, event_memory)
# factorizing event memory
df = df |>
mutate(event_memory = factor(df$event_memory, levels = c(0, 1), labels = c("No", "Yes")))
# Count the occurrences of 'Yes' and 'No' responses for each movie
movie_memory = df |>
group_by(Movie, event_memory) |>
summarise(count = n(), .groups = "drop") |>
pivot_wider(names_from = event_memory, values_from = count, values_fill = list(count = 0))
# Remove movies with 0 yes or 0 no
movie_memory_filtered = movie_memory |>
filter(Yes > 0 & No > 0)
# Join the filtered movie_memory with df to retain only movies with both Yes and No responses
df = df |>
filter(Movie %in% movie_memory_filtered$Movie)
# factorize movies, add event effect coding
df = df |>
mutate(Movie = factor(Movie),
event_effect = ifelse(event_memory ==  "Yes", 1, -1))
# create MEGA memory metric
df = df |>
mutate(MEGA_memory = MEGA_Z * event_effect)
# make dummy variable for each movie
dummy_dict = model.matrix(~ Movie - 1, data = df)
df = cbind(df, dummy_dict)
source("~/GitHub/R_Course_2024/final_project/analysis.R", echo=TRUE)
source("~/GitHub/R_Course_2024/final_project/RF_RFE.R", echo=TRUE)
# Recursive Feature Elimination
rfe_model = rfe(df[, 8:length(df)], df$MEGA_memory,
sizes = c(1:10),
rfeControl = rfeControl(functions = rfFuncs, method = "cv"))
conn <- file("data.txt", "r")  # Open a file connection
print(conn)
# Recursive Feature Elimination
rfe_model = rfe(df[, 8:length(df)], df$MEGA_memory,
sizes = c(1:10),
rfeControl = rfeControl(functions = rfFuncs, method = "cv"))
library(caret)
library(randomForest)
# Recursive Feature Elimination
rfe_model = rfe(df[, 8:length(df)], df$MEGA_memory,
sizes = c(1:10),
rfeControl = rfeControl(functions = rfFuncs, method = "cv"))
# random forest model
rf_model = randomForest(MEGA_memory ~ . - event_effect - event_memory, data = df[5:length(df)], importance = TRUE)
# View importance
importance(rf_model)
# Plot importance
varImpPlot(rf_model)
rf_importance_values = importance(rf_model)
rf_sorted_importance = rf_importance_values[order(-rf_importance_values[, 1]),]
rf_movies = rownames(rf_sorted_importance)
